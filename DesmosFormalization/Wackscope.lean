import DesmosFormalization.Types
-- a wackscope envionment containing the implicit dependencies
-- and the possible types
structure Wackscope where
  deps : Finset Name
  scheme : List (Ty × (deps -> Ty))

structure FnWackscope where
  deps : Finset Name
  scheme : List (BinOpSignature × (deps -> Ty))

def Wackscope.empty : Wackscope := {
  deps := ∅
  scheme := ∅
}

def isEmpty (w : Wackscope) : Prop := w.scheme = ∅

def hasDeps (w : Wackscope) : Prop := w.deps != ∅

-- restricts the type of the expression to one of the provided types
def restrict (w : Wackscope) (types : Finset Ty) : Wackscope :=
  {
    deps  := w.deps
    scheme := w.scheme.filter (·.1 ∈ types)
  }

-- takes 2 wackscopes and returns the wackscope generated by (w₁ op w₂).
def mergeByOp (w₁ w₂ : Wackscope) (op : BinOp)
  : Wackscope :=

  -- the dependencies are now the union of the dependencies of the lhs and the rhs
  let deps_union := w₁.deps ∪ w₂.deps

  -- the scheme takes whatever signatures the op allows,
  -- provided that the lhs and rhs match the parameter types
  -- and that the dependencies don't clash for that type assignment
  let scheme :=
    (w₁.scheme.product w₂.scheme).filterMap
    fun ((τ₁, s₁), (τ₂, s₂)) => do

        let signature <- (op.signatures.filter (·.params = (τ₁, τ₂)))[1]?
        if ∀ x (h₁ : x ∈ w₁.deps) (h₂ : x ∈ w₂.deps), s₁ ⟨x, h₁⟩ = s₂ ⟨x, h₂⟩ then

          -- union the functions with domains w₁.deps, w₂.deps
          -- into one function with the union as the domain
          let f (x : deps_union) : Ty := by
            by_cases h₁ : x.val ∈ w₁.deps
            · exact s₁ ⟨x.val, h₁⟩
            · have h₂ : x.val ∈ w₂.deps.val := by grind
              exact s₂ ⟨x.val, h₂⟩
          some (signature.ret, f)
        else none

  ⟨deps_union, scheme⟩

def Wackscope.eliminateDeps (w: Wackscope) (names : Finset Name) : Wackscope :=
  let ⟨deps, types⟩ := w
  let deps' := deps \ names
  let h_subset : deps' ⊆ deps := by exact Finset.sdiff_subset
  let types' := types.map fun ⟨τ, f⟩ => (τ, fun ⟨x, hx⟩ => f ⟨x, h_subset hx⟩)
  ⟨deps', types'⟩


-- Add := { (number × number) × number, (point × point) × point }

-- infer add a b =
--   α := infer a (deps & type candidates)           // number, point
--   β := infer b (deps & type candidates)           // number

--   let types := Add.filter(·.1 ∈ α.types ⨯ β.types)
--   α.restrict(types.1.1)  // number
--   β.restrict(types.1.2)  // number

--   (α, β, γ) : types ↦ (γ, fun dep => if dep ∈ α then α(dep) else β(dep)

--   deps := α.deps ∪ β.deps
--   types := types.map(fun τ => α when α.type == τ)
--           // Ty × (deps -> Ty)
