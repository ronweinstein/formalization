import DesmosFormalization.Types
-- a wackscope envionment containing the implicit dependencies
-- and the possible types
structure Wackscope where
  deps : Finset Name
  types : Finset (Ty × (deps -> Ty))

def Wackscope.empty : Wackscope := {
  deps := ∅
  types := ∅
}


def isEmpty (w : Wackscope) : Prop := w.types = ∅

def hasDeps (w : Wackscope) : Prop := w.deps != ∅

-- def merge (w₁ w₂ : Wackscope) : Option Wackscope :=

-- restricts the type of the expression to one of the provided types
def restrict (w : Wackscope) (types : Finset Ty) : Wackscope :=
  {
    deps  := w.deps
    types := w.types.filter (·.1 ∈ types)
  }

-- takes 2 wackscopes and returns the wackscope generated by (w₁ op w₂).
def mergeByOp (w₁ w₂ : Wackscope) (op : BinOp)
  : Wackscope :=

  let deps_union := w₁.deps ∪ w₂.deps
  -- let deps_isect := w₁.deps ∩ w₂.deps
  let signatures := op.signatures

  let types : Finset (Ty × (deps_union -> Ty)) := by sorry
    -- (w₁.types.product w₂.types).filterMap fun
    --   ((τ₁, f₁), (τ₂, f₂)) =>
    --     if ∃ signature ∈ signatures, (τ₁, τ₂) = signature.params
    --       ∧ ∀ d (h₁ : d ∈ w₁.deps) (h₂ : d ∈ w₂.deps), f₁ ⟨d, h₁⟩ = f₂ ⟨d, h₂⟩ then
    --       have f (x : deps_union) : Ty := by
    --         by_cases h₁ : x.val ∈ w₁.deps
    --         · exact f₁ ⟨x.val, h₁⟩
    --         · have h₂ : x.val ∈ w₂.deps := by
    --             have x.val ∈ w₁.deps ∪ w₂.deps := x.property
    --             simpa [Finset.mem_union, h₁] using this
    --           exact f₂ ⟨x.val, h₂⟩
    --       some (signature.ret, f)
    --     else none




    -- ((w₁.types.product w₂.types).product signatures).filterMap ( fun ⟨((τ₁, f₁), (τ₂, f₂)), sig⟩ =>
    --   let h := ∀ d (h₁ : d ∈ w₁.deps) (h₂ : d ∈ w₂.deps), f₁ ⟨d, h₁⟩ = f₂ ⟨d, h₂⟩
    --   if (τ₁, τ₂) = sig.params
    --     ∧ h
    --   then some (sig.ret, fun d : deps_union =>
    --     if h₁ : d.val ∈ w₁.deps
    --     then f₁ ⟨d.val, h₁⟩
    --     else
    --       have h₂ : d.val ∈ w₂.deps := by cases h₁; assumption
    --       f₂ ⟨d.val, h₂⟩
    --     )
    --   else none
    -- )

  {
    deps := deps_union
    types := types
  }



-- Add := { (number × number) × number, (point × point) × point }

-- infer add a b =
--   α := infer a (deps & type candidates)           // number, point
--   β := infer b (deps & type candidates)           // number

--   let types := Add.filter(·.1 ∈ α.types ⨯ β.types)
--   α.restrict(types.1.1)  // number
--   β.restrict(types.1.2)  // number

--   (α, β, γ) : types ↦ (γ, fun dep => if dep ∈ α then α(dep) else β(dep)

--   deps := α.deps ∪ β.deps
--   types := types.map(fun τ => α when α.type == τ)
--           // Ty × (deps -> Ty)
