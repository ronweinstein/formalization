import DesmosFormalization.Types
-- a wackscope envionment containing the implicit freevar dependencies
-- and the possible types
structure Wackscope where
  deps : Finset Name
  scheme : List (Ty × (deps -> Ty))

-- a function wackscope additionally stores its parameter names
-- (explicit dependencies)
structure FnWackscope where
  deps : Finset Name
  scheme : List (BinOpSignature × (deps -> Ty))

def Wackscope.empty : Wackscope := ⟨∅, []⟩


-- takes 2 wackscopes and returns the wackscope generated by (w₁ op w₂).
def mergeByOp (w₁ w₂ : Wackscope) (op : BinOp) : Wackscope :=

  -- the dependencies are now the union of the dependencies of the lhs and the rhs
  let deps := w₁.deps ∪ w₂.deps

  -- the scheme takes whatever signatures the op allows,
  -- provided that the lhs and rhs match the parameter types
  -- and that the dependencies don't clash for that type assignment
  let scheme :=
    (w₁.scheme.product w₂.scheme).filterMap
      fun ((τ₁, f₁), (τ₂, f₂)) => do

        let signature <- op.signatures.find? (·.params = (τ₁, τ₂))
        if ∀ x (h₁ : x ∈ w₁.deps) (h₂ : x ∈ w₂.deps), f₁ ⟨x, h₁⟩ = f₂ ⟨x, h₂⟩ then

          -- union the functions with domains w₁.deps, w₂.deps
          -- into one function with the union as the domain
          let f (x : deps) : Ty := by
            by_cases h₁ : x.val ∈ w₁.deps
            · exact f₁ ⟨x.val, h₁⟩
            · have h₂ : x.val ∈ w₂.deps.val := by grind
              exact f₂ ⟨x.val, h₂⟩
          some (signature.ret, f)
        else none

  ⟨deps, scheme⟩

-- takes 2 wackscopes and a function and produces the wackscope resulting from the function application
-- w₁, w₂, wf need to agree on dep types
def mergeByFn (w₁ w₂ : Wackscope) (wf : FnWackscope) : Wackscope :=

    let deps := w₁.deps ∪ w₂.deps ∪ wf.deps

-- the procedure is identical to mergeByOp
    let scheme :=
      (w₁.scheme.product w₂.scheme).filterMap
        fun ((τ₁, f₁), (τ₂, f₂)) => do

          let ⟨signature, f₃⟩ <- wf.scheme.find? (·.1.params = (τ₁, τ₂))

          if ∀ x (h₁ : x ∈ w₁.deps) (h₂ : x ∈ w₂.deps) (h₃ : x ∈ wf.deps),
            f₁ ⟨x, h₁⟩ = f₂ ⟨x, h₂⟩ ∧ f₁ ⟨x, h₁⟩ = f₃ ⟨x, h₃⟩ then

            let f (x : deps) : Ty := by
              by_cases h₁ : x.val ∈ w₁.deps
              · exact f₁ ⟨x.val, h₁⟩
              · by_cases h₂ : x.val ∈ w₂.deps
                · exact f₂ ⟨x.val, h₂⟩
                · have h₃ : x.val ∈ wf.deps := by grind
                  exact f₃ ⟨x.val, h₃⟩
            some (signature.ret, f)
          else
            none
    ⟨deps, scheme⟩
