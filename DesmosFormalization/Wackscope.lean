import DesmosFormalization.Types
-- a wackscope envionment containing the implicit freevar dependencies
-- and the possible types
structure Scheme where
  deps : Finset Name
  scheme : List (Ty × (deps -> Ty))

-- a function wackscope additionally stores its parameter names
-- (explicit dependencies)
structure FnScheme where
  deps : Finset Name
  scheme : List (BinOpSignature × (deps -> Ty))

def Scheme.empty : Scheme := ⟨∅, []⟩
def Scheme.freeVar (x : Name) : Scheme := ⟨{ x }, allTys.map fun τ => ⟨τ, fun _ => τ⟩⟩

-- takes 2 wackscopes and returns the wackscope generated by (s₁ op s₂).
def mergeByOp (s₁ s₂ : Scheme) (op : BinOp) : Scheme :=

  -- the dependencies are now the union of the dependencies of the lhs and the rhs
  let deps := s₁.deps ∪ s₂.deps

  -- the scheme takes whatever signatures the op allows,
  -- provided that the lhs and rhs match the parameter types
  -- and that the dependencies don't clash for that type assignment
  let scheme :=
    (s₁.scheme.product s₂.scheme).filterMap
      fun ((τ₁, f₁), (τ₂, f₂)) => do

        let signature <- op.signatures.find? (·.params = (τ₁, τ₂))
        if ∀ x (h₁ : x ∈ s₁.deps) (h₂ : x ∈ s₂.deps), f₁ ⟨x, h₁⟩ = f₂ ⟨x, h₂⟩ then

          -- union the functions with domains s₁.deps, s₂.deps
          -- into one function with the union as the domain
          let f (x : deps) : Ty := by
            by_cases h₁ : x.val ∈ s₁.deps
            · exact f₁ ⟨x.val, h₁⟩
            · have h₂ : x.val ∈ s₂.deps.val := by grind
              exact f₂ ⟨x.val, h₂⟩
          some (signature.ret, f)
        else none

  ⟨deps, scheme⟩

-- takes 2 wackscopes and a function and produces the wackscope resulting from the function application
-- s₁, s₂, wf need to agree on dep types
def mergeByFn (s₁ s₂ : Scheme) (fs : FnScheme) : Scheme :=

    let deps := s₁.deps ∪ s₂.deps ∪ fs.deps

-- the procedure is identical to mergeByOp
    let scheme :=
      (s₁.scheme.product s₂.scheme).filterMap
        fun ((τ₁, f₁), (τ₂, f₂)) => do

          let ⟨signature, f₃⟩ <- fs.scheme.find? (·.1.params = (τ₁, τ₂))

          if ∀ x (h₁ : x ∈ s₁.deps) (h₂ : x ∈ s₂.deps) (h₃ : x ∈ fs.deps),
            f₁ ⟨x, h₁⟩ = f₂ ⟨x, h₂⟩ ∧ f₁ ⟨x, h₁⟩ = f₃ ⟨x, h₃⟩ then

            let f (x : deps) : Ty := by
              by_cases h₁ : x.val ∈ s₁.deps
              · exact f₁ ⟨x.val, h₁⟩
              · by_cases h₂ : x.val ∈ s₂.deps
                · exact f₂ ⟨x.val, h₂⟩
                · have h₃ : x.val ∈ fs.deps := by grind
                  exact f₃ ⟨x.val, h₃⟩
            some (signature.ret, f)
          else
            none
    ⟨deps, scheme⟩
