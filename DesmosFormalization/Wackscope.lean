import DesmosFormalization.Types
-- a wackscope envionment containing the implicit freevar dependencies
-- and the possible types
structure Wackscope where
  deps : Finset Name
  scheme : List (Ty × (deps -> Ty))

-- a function wackscope additionally stores its parameter names
-- (explicit dependencies)
structure FnWackscope where
  deps : Finset Name
  scheme : List (BinOpSignature × (deps -> Ty))

def Wackscope.empty : Wackscope := ⟨∅, []⟩

def isEmpty (w : Wackscope) : Prop := w.scheme = ∅

def hasDeps (w : Wackscope) : Prop := w.deps != ∅

-- restricts the type of the expression to one of the provided types
def restrict (w : Wackscope) (types : Finset Ty) : Wackscope :=
  {
    deps  := w.deps
    scheme := w.scheme.filter (·.1 ∈ types)
  }

-- takes 2 wackscopes and returns the wackscope generated by (w₁ op w₂).
def mergeByOp (w₁ w₂ : Wackscope) (op : BinOp) : Wackscope :=

  -- the dependencies are now the union of the dependencies of the lhs and the rhs
  let deps := w₁.deps ∪ w₂.deps

  -- the scheme takes whatever signatures the op allows,
  -- provided that the lhs and rhs match the parameter types
  -- and that the dependencies don't clash for that type assignment
  let scheme :=
    (w₁.scheme.product w₂.scheme).filterMap
      fun ((τ₁, f₁), (τ₂, f₂)) => do

        let signature <- op.signatures.find? (·.params = (τ₁, τ₂))
        if ∀ x (h₁ : x ∈ w₁.deps) (h₂ : x ∈ w₂.deps), f₁ ⟨x, h₁⟩ = f₂ ⟨x, h₂⟩ then

          -- union the functions with domains w₁.deps, w₂.deps
          -- into one function with the union as the domain
          let f (x : deps) : Ty := by
            by_cases h₁ : x.val ∈ w₁.deps
            · exact f₁ ⟨x.val, h₁⟩
            · have h₂ : x.val ∈ w₂.deps.val := by grind
              exact f₂ ⟨x.val, h₂⟩
          some (signature.ret, f)
        else none

  ⟨deps, scheme⟩

-- takes 2 wackscopes and a function and produces the wackscope resulting from the function application
-- w₁, w₂, wf need to agree on dep types
def mergeByFn (w₁ w₂ : Wackscope) (wf : FnWackscope) : Wackscope :=

    let deps := w₁.deps ∪ w₂.deps ∪ wf.deps

-- the procedure is identical to mergeByOp
    let scheme :=
      (w₁.scheme.product w₂.scheme).filterMap
        fun ((τ₁, f₁), (τ₂, f₂)) => do

          let ⟨signature, f₃⟩ <- wf.scheme.find? (·.1.params = (τ₁, τ₂))

          if ∀ x (h₁ : x ∈ w₁.deps) (h₂ : x ∈ w₂.deps) (h₃ : x ∈ wf.deps),
            f₁ ⟨x, h₁⟩ = f₂ ⟨x, h₂⟩ ∧ f₁ ⟨x, h₁⟩ = f₃ ⟨x, h₃⟩ then

            let f (x : deps) : Ty := by
              by_cases h₁ : x.val ∈ w₁.deps
              · exact f₁ ⟨x.val, h₁⟩
              · by_cases h₂ : x.val ∈ w₂.deps
                · exact f₂ ⟨x.val, h₂⟩
                · have h₃ : x.val ∈ wf.deps := by grind
                  exact f₃ ⟨x.val, h₃⟩
            some (signature.ret, f)
          else
            none
    ⟨deps, scheme⟩




def Wackscope.eliminateDeps (w: Wackscope) (names : Finset Name) : Wackscope :=
  let ⟨deps, types⟩ := w
  let deps' := deps \ names
  let h_subset : deps' ⊆ deps := by exact Finset.sdiff_subset
  let types' := types.map fun ⟨τ, f⟩ => (τ, fun ⟨x, hx⟩ => f ⟨x, h_subset hx⟩)
  ⟨deps', types'⟩


-- Add := { (number × number) × number, (point × point) × point }

-- infer add a b =
--   α := infer a (deps & type candidates)           // number, point
--   β := infer b (deps & type candidates)           // number

--   let types := Add.filter(·.1 ∈ α.types ⨯ β.types)
--   α.restrict(types.1.1)  // number
--   β.restrict(types.1.2)  // number

--   (α, β, γ) : types ↦ (γ, fun dep => if dep ∈ α then α(dep) else β(dep)

--   deps := α.deps ∪ β.deps
--   types := types.map(fun τ => α when α.type == τ)
--           // Ty × (deps -> Ty)
